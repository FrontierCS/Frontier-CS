import os
import re


class Solution:
    def solve(self, resources_path: str) -> dict:
        grammar_path = os.path.join(resources_path, "sql_grammar.txt")
        try:
            with open(grammar_path, "r", encoding="utf-8", errors="ignore") as f:
                grammar_text = f.read()
        except Exception:
            grammar_text = ""

        fuzzer_code = (
            "import time, random, re\n"
            "\n"
            f"GRAMMAR_TEXT = {grammar_text!r}\n"
            "\n"
            "_OPS2 = {'!=','<=','>=','<>','||','<<','>>','::'}\n"
            "_OPS1 = set('=<>+-*/%~^&?:')\n"
            "_SPECIAL = set('[]{}()|?*+;,.')\n"
            "_PUNCT = set(',;')\n"
            "_NO_SPACE_BEFORE = {',', ')', ';', '.', ']', '}', '%'}\n"
            "_NO_SPACE_AFTER = {'(', '.', '[', '{'}\n"
            "\n"
            "def _rhs_tokenize(s: str):\n"
            "    toks = []\n"
            "    i = 0\n"
            "    n = len(s)\n"
            "    while i < n:\n"
            "        c = s[i]\n"
            "        if c.isspace():\n"
            "            i += 1\n"
            "            continue\n"
            "        if c in ('\"', \"'\"):\n"
            "            q = c\n"
            "            j = i + 1\n"
            "            while j < n:\n"
            "                d = s[j]\n"
            "                if d == q:\n"
            "                    j += 1\n"
            "                    if q == \"'\" and j < n and s[j] == \"'\":\n"
            "                        j += 1\n"
            "                        continue\n"
            "                    break\n"
            "                j += 1\n"
            "            toks.append(s[i:j])\n"
            "            i = j\n"
            "            continue\n"
            "        if c == '<':\n"
            "            j = s.find('>', i + 1)\n"
            "            if j != -1:\n"
            "                toks.append(s[i:j+1])\n"
            "                i = j + 1\n"
            "                continue\n"
            "        if i + 1 < n and s[i:i+2] in _OPS2:\n"
            "            toks.append(s[i:i+2])\n"
            "            i += 2\n"
            "            continue\n"
            "        if c in _SPECIAL or c in _OPS1:\n"
            "            toks.append(c)\n"
            "            i += 1\n"
            "            continue\n"
            "        j = i + 1\n"
            "        while j < n:\n"
            "            d = s[j]\n"
            "            if d.isspace() or d in _SPECIAL or d in _OPS1 or d in ('\"', \"'\", '<'):\n"
            "                break\n"
            "            if j + 1 < n and s[j:j+2] in _OPS2:\n"
            "                break\n"
            "            j += 1\n"
            "        toks.append(s[i:j])\n"
            "        i = j\n"
            "    return toks\n"
            "\n"
            "def _strip_comment(line: str):\n"
            "    for m in ('#', '//'):\n"
            "        p = line.find(m)\n"
            "        if p != -1:\n"
            "            return line[:p]\n"
            "    return line\n"
            "\n"
            "def _norm_sym(x: str):\n"
            "    x = x.strip()\n"
            "    if x.startswith('<') and x.endswith('>') and len(x) > 2:\n"
            "        return x[1:-1].strip()\n"
            "    return x\n"
            "\n"
            "class _EBNF:\n"
            "    __slots__ = ('rules', 'order')\n"
            "    def __init__(self, text: str):\n"
            "        self.rules = {}\n"
            "        self.order = []\n"
            "        self._parse(text)\n"
            "\n"
            "    def _parse(self, text: str):\n"
            "        lines = text.splitlines()\n"
            "        for raw in lines:\n"
            "            line = _strip_comment(raw).strip()\n"
            "            if not line:\n"
            "                continue\n"
            "            if '::=' in line:\n"
            "                lhs, rhs = line.split('::=', 1)\n"
            "            elif '->' in line:\n"
            "                lhs, rhs = line.split('->', 1)\n"
            "            else:\n"
            "                continue\n"
            "            lhs = _norm_sym(lhs)\n"
            "            rhs = rhs.strip()\n"
            "            if rhs.endswith(';'):\n"
            "                rhs = rhs[:-1].strip()\n"
            "            if not lhs or not rhs:\n"
            "                continue\n"
            "            toks = _rhs_tokenize(rhs)\n"
            "            if not toks:\n"
            "                continue\n"
            "            parser = _EBNFParser(toks)\n"
            "            node = parser.parse_expr(stop=None)\n"
            "            alts = node[1] if node and node[0] == 'alt' else [node]\n"
            "            self.rules[lhs] = alts\n"
            "            self.order.append(lhs)\n"
            "\n"
            "class _EBNFParser:\n"
            "    __slots__ = ('toks','i','n')\n"
            "    def __init__(self, toks):\n"
            "        self.toks = toks\n"
            "        self.i = 0\n"
            "        self.n = len(toks)\n"
            "\n"
            "    def _peek(self):\n"
            "        return self.toks[self.i] if self.i < self.n else None\n"
            "\n"
            "    def _eat(self, t=None):\n"
            "        if self.i >= self.n:\n"
            "            return None\n"
            "        cur = self.toks[self.i]\n"
            "        if t is not None and cur != t:\n"
            "            return None\n"
            "        self.i += 1\n"
            "        return cur\n"
            "\n"
            "    def parse_expr(self, stop=None):\n"
            "        if stop is None:\n"
            "            stop = set()\n"
            "        left = self.parse_seq(stop | {'|'})\n"
            "        alts = [left]\n"
            "        while True:\n"
            "            p = self._peek()\n"
            "            if p == '|':\n"
            "                self._eat('|')\n"
            "                alts.append(self.parse_seq(stop | {'|'}) )\n"
            "            else:\n"
            "                break\n"
            "        if len(alts) == 1:\n"
            "            return alts[0]\n"
            "        return ('alt', alts)\n"
            "\n"
            "    def parse_seq(self, stop):\n"
            "        items = []\n"
            "        while True:\n"
            "            p = self._peek()\n"
            "            if p is None or p in stop or p in (']','}',')'):\n"
            "                break\n"
            "            items.append(self.parse_factor(stop))\n"
            "        if not items:\n"
            "            return ('seq', [])\n"
            "        if len(items) == 1:\n"
            "            return items[0]\n"
            "        return ('seq', items)\n"
            "\n"
            "    def parse_factor(self, stop):\n"
            "        atom = self.parse_atom(stop)\n"
            "        p = self._peek()\n"
            "        if p in ('?','*','+'):\n"
            "            op = self._eat()\n"
            "            if op == '?':\n"
            "                return ('opt', atom)\n"
            "            if op == '*':\n"
            "                return ('rep', atom, 0, 3)\n"
            "            return ('rep', atom, 1, 3)\n"
            "        return atom\n"
            "\n"
            "    def parse_atom(self, stop):\n"
            "        p = self._peek()\n"
            "        if p is None:\n"
            "            return ('seq', [])\n"
            "        if p == '(':\n"
            "            self._eat('(')\n"
            "            e = self.parse_expr(stop | {')'})\n"
            "            self._eat(')')\n"
            "            return e\n"
            "        if p == '[':\n"
            "            self._eat('[')\n"
            "            e = self.parse_expr(stop | {']'})\n"
            "            self._eat(']')\n"
            "            return ('opt', e)\n"
            "        if p == '{':\n"
            "            self._eat('{')\n"
            "            e = self.parse_expr(stop | {'}'})\n"
            "            self._eat('}')\n"
            "            return ('rep', e, 0, 3)\n"
            "        tok = self._eat()\n"
            "        return ('tok', tok)\n"
            "\n"
            "def _tokens_to_sql(tokens):\n"
            "    out = []\n"
            "    prev = ''\n"
            "    for t in tokens:\n"
            "        if t is None:\n"
            "            continue\n"
            "        if t == '':\n"
            "            continue\n"
            "        if not out:\n"
            "            out.append(t)\n"
            "        else:\n"
            "            if t in _NO_SPACE_BEFORE or prev in _NO_SPACE_AFTER:\n"
            "                out.append(t)\n"
            "            else:\n"
            "                out.append(' ' + t)\n"
            "        prev = t\n"
            "    return ''.join(out)\n"
            "\n"
            "def _rand_ident(rng, base=None):\n"
            "    if base is None:\n"
            "        base = rng.choice(['t','tbl','users','orders','items','x','y','z','col','id','name','value','a','b','c','d','e','f'])\n"
            "    if rng.random() < 0.55:\n"
            "        base = base + str(rng.randrange(0, 50))\n"
            "    if rng.random() < 0.08:\n"
            "        base = base + '_' + rng.choice(['tmp','old','new','idx','ref','kv','aux'])\n"
            "    q = rng.random()\n"
            "    if q < 0.08:\n"
            "        return '\"' + base.replace('\"','\"\"') + '\"'\n"
            "    if q < 0.14:\n"
            "        return '`' + base.replace('`','``') + '`'\n"
            "    if q < 0.18:\n"
            "        return '[' + base.replace(']','') + ']'\n"
            "    return base\n"
            "\n"
            "def _rand_num(rng):\n"
            "    r = rng.random()\n"
            "    if r < 0.15:\n"
            "        return str(rng.randrange(-10, 11))\n"
            "    if r < 0.35:\n"
            "        return str(rng.randrange(0, 100000))\n"
            "    if r < 0.55:\n"
            "        return ('-' if rng.random() < 0.2 else '') + str(rng.randrange(0, 1000)) + '.' + str(rng.randrange(0, 1000))\n"
            "    if r < 0.75:\n"
            "        return str(rng.randrange(0, 1000)) + 'e' + ('+' if rng.random() < 0.5 else '-') + str(rng.randrange(0, 50))\n"
            "    if r < 0.90:\n"
            "        return '0x' + format(rng.randrange(0, 1<<16), 'x')\n"
            "    return '.' + str(rng.randrange(0, 1000))\n"
            "\n"
            "def _rand_str(rng):\n"
            "    r = rng.random()\n"
            "    if r < 0.08:\n"
            "        return \"''\"\n"
            "    s = rng.choice(['a','b','c','test','xyz','hello','world','NULL','true','false','%','_',';','--','/*','*/','\"','\\\\'])\n"
            "    if rng.random() < 0.5:\n"
            "        s += rng.choice(['','', '1','2','3','_x','-y'])\n"
            "    if rng.random() < 0.25:\n"
            "        s = s + \"'\" + rng.choice(['q','w','e','''','\"'])\n"
            "    s = s.replace(\"'\", \"''\")\n"
            "    return \"'\" + s + \"'\"\n"
            "\n"
            "def _maybe_semicolon(rng, s):\n"
            "    s2 = s.strip()\n"
            "    if not s2:\n"
            "        return s2\n"
            "    if s2.endswith(';'):\n"
            "        return s2\n"
            "    if rng.random() < 0.55:\n"
            "        return s2 + ';'\n"
            "    return s2\n"
            "\n"
            "class _SQLFuzzer:\n"
            "    __slots__ = ('rng','g','rules','start_syms','alt_use','templates','corpus','seen','max_seen','last_parse_dt','target_dt')\n"
            "    def __init__(self, rng):\n"
            "        self.rng = rng\n"
            "        self.g = _EBNF(GRAMMAR_TEXT or '')\n"
            "        self.rules = self.g.rules\n"
            "        self.start_syms = self._pick_start_symbols()\n"
            "        self.alt_use = {k: [0]*len(v) for k,v in self.rules.items()}\n"
            "        self.templates = self._build_templates()\n"
            "        self.corpus = []\n"
            "        self.seen = set()\n"
            "        self.max_seen = 20000\n"
            "        self.last_parse_dt = 0.0\n"
            "        self.target_dt = 0.9\n"
            "        self._seed_corpus()\n"
            "\n"
            "    def _pick_start_symbols(self):\n"
            "        if not self.rules:\n"
            "            return []\n"
            "        keys = list(self.rules.keys())\n"
            "        low = [(k.lower(), k) for k in keys]\n"
            "        cand = []\n"
            "        for kl, k in low:\n"
            "            if 'stmt' in kl or 'statement' in kl or 'command' in kl or 'cmd' in kl:\n"
            "                cand.append(k)\n"
            "        for name in ('sql_stmt_list','sql_stmt','statement','stmt','query','select_stmt'):\n"
            "            for k in keys:\n"
            "                if k.lower() == name:\n"
            "                    if k not in cand:\n"
            "                        cand.insert(0, k)\n"
            "        if not cand:\n"
            "            cand = [keys[0]]\n"
            "        # Deduplicate preserving order\n"
            "        out = []\n"
            "        seen = set()\n"
            "        for k in cand:\n"
            "            if k not in seen:\n"
            "                seen.add(k)\n"
            "                out.append(k)\n"
            "        return out[:12]\n"
            "\n"
            "    def _build_templates(self):\n"
            "        T = []\n"
            "        T.append(\"SELECT 1\")\n"
            "        T.append(\"SELECT * FROM {t}\")\n"
            "        T.append(\"SELECT {c1}, {c2} FROM {t} WHERE {c1} = 1\")\n"
            "        T.append(\"SELECT DISTINCT {c1} FROM {t} ORDER BY {c1} LIMIT 10 OFFSET 1\")\n"
            "        T.append(\"SELECT {c1} AS x, {c2} + 1 AS y FROM {t} WHERE {c2} BETWEEN 1 AND 10\")\n"
            "        T.append(\"SELECT COUNT(*) FROM {t}\")\n"
            "        T.append(\"SELECT {c1} FROM {t} WHERE {c1} IN (SELECT {c1} FROM {t2} WHERE {c1} IS NOT NULL)\")\n"
            "        T.append(\"SELECT {c1} FROM {t} WHERE EXISTS (SELECT 1 FROM {t2} WHERE {t2}.{c1} = {t}.{c1})\")\n"
            "        T.append(\"SELECT {t}.{c1}, {t2}.{c2} FROM {t} JOIN {t2} ON {t}.{c1} = {t2}.{c1}\")\n"
            "        T.append(\"SELECT * FROM (SELECT {c1} FROM {t} WHERE {c1} > 0) AS sub\")\n"
            "        T.append(\"WITH cte(x) AS (SELECT 1) SELECT x FROM cte\")\n"
            "        T.append(\"WITH RECURSIVE cte(x) AS (SELECT 1 UNION ALL SELECT x+1 FROM cte WHERE x<3) SELECT x FROM cte\")\n"
            "        T.append(\"VALUES (1,2),(3,4)\")\n"
            "        T.append(\"INSERT INTO {t} ({c1},{c2}) VALUES (1,{s1}),(2,{s2})\")\n"
            "        T.append(\"INSERT INTO {t} DEFAULT VALUES\")\n"
            "        T.append(\"UPDATE {t} SET {c1} = {c1} + 1, {c2} = {s1} WHERE {c1} >= 0\")\n"
            "        T.append(\"DELETE FROM {t} WHERE {c1} < 0 OR {c2} IS NULL\")\n"
            "        T.append(\"CREATE TABLE {t} (id INTEGER PRIMARY KEY, {c1} TEXT NOT NULL, {c2} REAL DEFAULT 1.0, CHECK (id>0))\")\n"
            "        T.append(\"CREATE TEMP TABLE {t} ({c1} INT, {c2} TEXT, UNIQUE({c1},{c2}))\")\n"
            "        T.append(\"CREATE INDEX {idx} ON {t} ({c1},{c2})\")\n"
            "        T.append(\"DROP TABLE IF EXISTS {t}\")\n"
            "        T.append(\"DROP INDEX IF EXISTS {idx}\")\n"
            "        T.append(\"ALTER TABLE {t} ADD COLUMN {c3} TEXT\")\n"
            "        T.append(\"CREATE VIEW {v} AS SELECT {c1} FROM {t} WHERE {c1} IS NOT NULL\")\n"
            "        T.append(\"DROP VIEW IF EXISTS {v}\")\n"
            "        T.append(\"BEGIN\")\n"
            "        T.append(\"COMMIT\")\n"
            "        T.append(\"ROLLBACK\")\n"
            "        T.append(\"EXPLAIN SELECT {c1} FROM {t} WHERE {c1} = 1\")\n"
            "        T.append(\"SELECT CASE WHEN {c1} > 0 THEN {s1} WHEN {c1} = 0 THEN {s2} ELSE {s3} END FROM {t}\")\n"
            "        T.append(\"SELECT COALESCE({c1}, 0), CAST({c2} AS TEXT) FROM {t}\")\n"
            "        T.append(\"SELECT {c1} FROM {t} WHERE {c2} LIKE {s_like} ESCAPE '\\\\'\")\n"
            "        T.append(\"SELECT {c1} FROM {t} UNION ALL SELECT {c1} FROM {t2}\")\n"
            "        T.append(\"PRAGMA foreign_keys=ON\")\n"
            "        T.append(\"PRAGMA table_info({t})\")\n"
            "        return T\n"
            "\n"
            "    def _fmt(self, tmpl):\n"
            "        rng = self.rng\n"
            "        t = _rand_ident(rng, 't')\n"
            "        t2 = _rand_ident(rng, 't2')\n"
            "        c1 = _rand_ident(rng, 'c1')\n"
            "        c2 = _rand_ident(rng, 'c2')\n"
            "        c3 = _rand_ident(rng, 'c3')\n"
            "        idx = _rand_ident(rng, 'idx')\n"
            "        v = _rand_ident(rng, 'v')\n"
            "        s1 = _rand_str(rng)\n"
            "        s2 = _rand_str(rng)\n"
            "        s3 = _rand_str(rng)\n"
            "        s_like = rng.choice([\"'%a%'\", \"'_%'\", \"'%\\\\_%'\", \"'%test%'\"])\n"
            "        try:\n"
            "            return tmpl.format(t=t, t2=t2, c1=c1, c2=c2, c3=c3, idx=idx, v=v, s1=s1, s2=s2, s3=s3, s_like=s_like)\n"
            "        except Exception:\n"
            "            return tmpl\n"
            "\n"
            "    def _seed_corpus(self):\n"
            "        for tmpl in self.templates:\n"
            "            s = self._fmt(tmpl)\n"
            "            s = _maybe_semicolon(self.rng, s)\n"
            "            self._add(s)\n"
            "        # Some oddballs\n"
            "        for s in (\n"
            "            \"\",\n"
            "            \" \",\n"
            "            \";\",\n"
            "            \"-- comment only\\n\",\n"
            "            \"/* block comment */\",\n"
            "            \"SELECT/*x*/1--y\\n\",\n"
            "            \"SELECT 1/* unterminated\",\n"
            "            \"SELECT 'unterminated\",\n"
            "            \"SELECT 1.0e+01, 0x10, .5, 1.\",\n"
            "            \"SELECT 1 FROM (SELECT 2)\",\n"
            "            \"SELECT 1 WHERE 1 IN (1,2,3)\",\n"
            "        ):\n"
            "            self._add(s)\n"
            "        # Grammar-derived initial seeds\n"
            "        for sym in self.start_syms[:6]:\n"
            "            for d in (4, 6, 8):\n"
            "                for _ in range(8):\n"
            "                    s = self._gen_from_symbol(sym, d)\n"
            "                    if s:\n"
            "                        self._add(_maybe_semicolon(self.rng, s))\n"
            "\n"
            "    def _add(self, s):\n"
            "        if s is None:\n"
            "            return\n"
            "        if len(s) > 1200:\n"
            "            return\n"
            "        if len(self.seen) < self.max_seen:\n"
            "            if s in self.seen:\n"
            "                return\n"
            "            self.seen.add(s)\n"
            "        self.corpus.append(s)\n"
            "\n"
            "    def _choose_alt(self, sym):\n"
            "        alts = self.rules.get(sym)\n"
            "        if not alts:\n"
            "            return None\n"
            "        use = self.alt_use.get(sym)\n"
            "        if not use or len(use) != len(alts):\n"
            "            use = [0]*len(alts)\n"
            "            self.alt_use[sym] = use\n"
            "        # pick among a few random candidates with minimal use\n"
            "        if len(alts) <= 2:\n"
            "            idx = 0 if use[0] <= use[-1] else len(alts)-1\n"
            "        else:\n"
            "            best = None\n"
            "            best_u = None\n"
            "            for _ in range(4):\n"
            "                j = self.rng.randrange(0, len(alts))\n"
            "                u = use[j]\n"
            "                if best is None or u < best_u:\n"
            "                    best = j\n"
            "                    best_u = u\n"
            "            idx = best\n"
            "        use[idx] += 1\n"
            "        return alts[idx]\n"
            "\n"
            "    def _gen_terminal(self, tok):\n"
            "        rng = self.rng\n"
            "        if tok is None:\n"
            "            return ''\n"
            "        if tok.startswith('<') and tok.endswith('>'):\n"
            "            tok = tok[1:-1].strip()\n"
            "        if len(tok) >= 2 and ((tok[0] == tok[-1] == \"'\") or (tok[0] == tok[-1] == '\"')):\n"
            "            return tok[1:-1]\n"
            "        tl = tok.lower()\n"
            "        if tl in ('ident','identifier','name','table_name','column_name','colname','dbname','schema_name','table','column'):\n"
            "            return _rand_ident(rng)\n"
            "        if 'ident' in tl or tl.endswith('_name') or tl.endswith('name'):\n"
            "            if rng.random() < 0.6:\n"
            "                return _rand_ident(rng)\n"
            "        if tl in ('int','integer','number','numeric','float','real','signed_number','unsigned_number'):\n"
            "            return _rand_num(rng)\n"
            "        if tl in ('string','str','text','literal','string_literal'):\n"
            "            return _rand_str(rng)\n"
            "        if tl in ('null','true','false'):\n"
            "            return tl.upper()\n"
            "        return tok\n"
            "\n"
            "    def _gen_node(self, node, depth, symstack, out_tokens, token_limit):\n"
            "        if node is None:\n"
            "            return\n"
            "        if len(out_tokens) >= token_limit:\n"
            "            return\n"
            "        t = node[0]\n"
            "        if t == 'tok':\n"
            "            out_tokens.append(self._gen_terminal(node[1]))\n"
            "            return\n"
            "        if t == 'seq':\n"
            "            for it in node[1]:\n"
            "                if len(out_tokens) >= token_limit:\n"
            "                    break\n"
            "                self._gen_node(it, depth, symstack, out_tokens, token_limit)\n"
            "            return\n"
            "        if t == 'alt':\n"
            "            alts = node[1]\n"
            "            if not alts:\n"
            "                return\n"
            "            choice = alts[self.rng.randrange(0, len(alts))]\n"
            "            self._gen_node(choice, depth, symstack, out_tokens, token_limit)\n"
            "            return\n"
            "        if t == 'opt':\n"
            "            if depth <= 0:\n"
            "                if self.rng.random() < 0.12:\n"
            "                    self._gen_node(node[1], depth-1, symstack, out_tokens, token_limit)\n"
            "            else:\n"
            "                if self.rng.random() < 0.55:\n"
            "                    self._gen_node(node[1], depth-1, symstack, out_tokens, token_limit)\n"
            "            return\n"
            "        if t == 'rep':\n"
            "            child, mn, mx = node[1], node[2], node[3]\n"
            "            if depth <= 0:\n"
            "                cnt = mn\n"
            "            else:\n"
            "                cap = mx\n"
            "                if depth <= 2:\n"
            "                    cap = min(cap, 1)\n"
            "                elif depth <= 4:\n"
            "                    cap = min(cap, 2)\n"
            "                cnt = self.rng.randrange(mn, cap + 1)\n"
            "            for _ in range(cnt):\n"
            "                if len(out_tokens) >= token_limit:\n"
            "                    break\n"
            "                self._gen_node(child, depth-1, symstack, out_tokens, token_limit)\n"
            "            return\n"
            "        # Unknown node\n"
            "        return\n"
            "\n"
            "    def _gen_from_symbol(self, sym, depth):\n"
            "        if not sym:\n"
            "            return ''\n"
            "        sym = _norm_sym(sym)\n"
            "        token_limit = 180\n"
            "        out = []\n"
            "        symstack = []\n"
            "        self._gen_symbol_into(sym, depth, symstack, out, token_limit)\n"
            "        s = _tokens_to_sql(out)\n"
            "        return s.strip()\n"
            "\n"
            "    def _gen_symbol_into(self, sym, depth, symstack, out_tokens, token_limit):\n"
            "        if len(out_tokens) >= token_limit:\n"
            "            return\n"
            "        sym = _norm_sym(sym)\n"
            "        if sym in self.rules:\n"
            "            if depth <= 0:\n"
            "                # avoid deep recursion by preferring shorter expansions\n"
            "                pass\n"
            "            if sym in symstack:\n"
            "                # recursion guard fallback\n"
            "                if sym.lower().endswith('expr') or sym.lower() in ('expr','expression'):\n"
            "                    out_tokens.append(_rand_num(self.rng))\n"
            "                elif 'name' in sym.lower() or 'ident' in sym.lower():\n"
            "                    out_tokens.append(_rand_ident(self.rng))\n"
            "                else:\n"
            "                    out_tokens.append('1')\n"
            "                return\n"
            "            symstack.append(sym)\n"
            "            alt = self._choose_alt(sym)\n"
            "            if alt is not None:\n"
            "                self._gen_node(alt, depth-1, symstack, out_tokens, token_limit)\n"
            "            symstack.pop()\n"
            "        else:\n"
            "            out_tokens.append(self._gen_terminal(sym))\n"
            "\n"
            "    def _mutate(self, s: str):\n"
            "        rng = self.rng\n"
            "        if not s:\n"
            "            return s\n"
            "        r = rng.random()\n"
            "        if r < 0.18:\n"
            "            # case perturbation\n"
            "            def flip(m):\n"
            "                w = m.group(0)\n"
            "                q = rng.random()\n"
            "                if q < 0.4:\n"
            "                    return w.upper()\n"
            "                if q < 0.8:\n"
            "                    return w.lower()\n"
            "                return ''.join((ch.upper() if rng.random() < 0.5 else ch.lower()) for ch in w)\n"
            "            return re.sub(r\"\\b[A-Za-z_][A-Za-z_0-9]*\\b\", flip, s)\n"
            "        if r < 0.38:\n"
            "            # insert comment\n"
            "            parts = re.split(r\"(\\s+)\", s)\n"
            "            if len(parts) <= 1:\n"
            "                return s\n"
            "            k = rng.randrange(0, len(parts))\n"
            "            com = rng.choice([\"/*x*/\", \"/* fuzz */\", \"--c\\n\", \"/*+hint*/\"]) \n"
            "            parts.insert(k, com)\n"
            "            return ''.join(parts)\n"
            "        if r < 0.58:\n"
            "            # whitespace weirdness\n"
            "            s2 = re.sub(r\"\\s+\", lambda m: rng.choice([' ', '  ', '\\n', '\\t', ' \\n ']), s)\n"
            "            return s2\n"
            "        if r < 0.73:\n"
            "            # wrap in parentheses or add trailing semicolon\n"
            "            if rng.random() < 0.5:\n"
            "                return '(' + s.strip() + ')'\n"
            "            return _maybe_semicolon(rng, s)\n"
            "        if r < 0.88:\n"
            "            # token deletion\n"
            "            toks = re.findall(r\"--.*?$|/\\*.*?\\*/|'(?:''|[^'])*'|\\S+\", s, flags=re.S|re.M)\n"
            "            if len(toks) < 3:\n"
            "                return s\n"
            "            j = rng.randrange(0, len(toks))\n"
            "            del toks[j]\n"
            "            return ' '.join(toks)\n"
            "        # make invalid-ish endings\n"
            "        return s + rng.choice([\" )\", \" (\", \" ,\", \" \", \" /*\"])\n"
            "\n"
            "    def make_batch(self, n, phase=0):\n"
            "        rng = self.rng\n"
            "        out = []\n"
            "        for _ in range(n):\n"
            "            p = rng.random()\n"
            "            if phase == 0 and p < 0.45:\n"
            "                s = self._fmt(rng.choice(self.templates))\n"
            "                s = _maybe_semicolon(rng, s)\n"
            "            elif self.rules and p < 0.82:\n"
            "                sym = rng.choice(self.start_syms) if self.start_syms else rng.choice(list(self.rules.keys()))\n"
            "                depth = 4 + rng.randrange(0, 7)\n"
            "                s = self._gen_from_symbol(sym, depth)\n"
            "                if not s:\n"
            "                    s = self._fmt(rng.choice(self.templates))\n"
            "                s = _maybe_semicolon(rng, s)\n"
            "            else:\n"
            "                if self.corpus:\n"
            "                    s = self._mutate(rng.choice(self.corpus))\n"
            "                else:\n"
            "                    s = self._fmt(rng.choice(self.templates))\n"
            "                if rng.random() < 0.4:\n"
            "                    s = _maybe_semicolon(rng, s)\n"
            "            if len(s) > 1400:\n"
            "                s = s[:1400]\n"
            "            out.append(s)\n"
            "            if len(self.corpus) < 9000 and (not self.seen or rng.random() < 0.85):\n"
            "                self._add(s)\n"
            "        return out\n"
            "\n"
            "    def adapt_batch_size(self, remaining, calls):\n"
            "        # Aim for ~target_dt per parse call, keep N moderate.\n"
            "        if remaining < 2.0:\n"
            "            return 150\n"
            "        if self.last_parse_dt <= 1e-6:\n"
            "            base = 900 if calls <= 5 else 650\n"
            "            return base\n"
            "        ratio = self.target_dt / max(0.05, self.last_parse_dt)\n"
            "        # Smooth and clamp\n"
            "        if ratio < 0.4:\n"
            "            ratio = 0.4\n"
            "        elif ratio > 2.2:\n"
            "            ratio = 2.2\n"
            "        # previous batch estimate from dt: assume proportional; adjust\n"
            "        est = int(getattr(self, '_last_n', 650) * ratio)\n"
            "        if calls <= 3:\n"
            "            est = max(est, 900)\n"
            "        est = max(120, min(est, 1600))\n"
            "        if remaining < 8.0:\n"
            "            est = min(est, 650)\n"
            "        self._last_n = est\n"
            "        return est\n"
            "\n"
            "_STATE = {}\n"
            "\n"
            "def fuzz(parse_sql):\n"
            "    st = _STATE\n"
            "    if not st:\n"
            "        st['t0'] = time.perf_counter()\n"
            "        seed = (time.time_ns() ^ (id(parse_sql) & 0xFFFFFFFF)) & 0xFFFFFFFFFFFFFFFF\n"
            "        rng = random.Random(seed)\n"
            "        st['rng'] = rng\n"
            "        st['f'] = _SQLFuzzer(rng)\n"
            "        st['calls'] = 0\n"
            "    st['calls'] += 1\n"
            "    f = st['f']\n"
            "    now = time.perf_counter()\n"
            "    elapsed = now - st['t0']\n"
            "    remaining = 59.4 - elapsed\n"
            "    if remaining <= 0.25:\n"
            "        return False\n"
            "    phase = 0 if st['calls'] <= 6 else 1\n"
            "    n = f.adapt_batch_size(remaining, st['calls'])\n"
            "    batch = f.make_batch(n, phase=phase)\n"
            "    t1 = time.perf_counter()\n"
            "    parse_sql(batch)\n"
            "    t2 = time.perf_counter()\n"
            "    f.last_parse_dt = (t2 - t1)\n"
            "    # Stop a bit early to reduce call count tail.\n"
            "    if (t2 - st['t0']) > 59.2:\n"
            "        return False\n"
            "    if st['calls'] >= 90 and remaining < 25.0:\n"
            "        return False\n"
            "    return True\n"
        )

        return {"code": fuzzer_code}